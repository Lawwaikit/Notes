## Goruntine

在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine

```go
func main() {
    go hello() // 启动另外一个goroutine去执行hello函数
    fmt.Println("main goroutine done!")
}
```

## channel通道

channel是一种类型，一种引用类型。声明通道类型的格式如下

```go
var 变量 chan 元素类型
//通道是引用类型，通道类型的空值是nil。
var ch chan int
fmt.Println(ch) // <nil>
```

举几个例子：

```go
var ch1 chan int   // 声明一个传递整型的通道
var ch2 chan bool  // 声明一个传递布尔型的通道
var ch3 chan []int // 声明一个传递int切片的通道
```

创建channel的格式如下，channel的缓冲大小是可选的。

```
make(chan 元素类型, [缓冲大小])
```

举几个例子：

```go
ch4 := make(chan int)
ch5 := make(chan bool)
ch6 := make(chan []int)
```

### channel操作

发送、接收、关闭

```go
ch := make(chan int)
ch <- 10 // 把10发送到ch中
x := <- ch // 从ch中接收值并赋值给变量x
<-ch       // 从ch中接收值，忽略结果
//通过调用内置的close函数来关闭通道。
 close(ch)
```

### 无缓冲通道和有缓冲通道

#### 无缓冲区的通道

- 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。
```go
func main() {
    ch := make(chan int)
    ch <- 10	//会阻塞
    fmt.Println("发送成功")
}
```
- 相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。
```go
func main() {
    ch := make(chan int)
    <- ch //会阻塞
    fmt.Println("接收成功")
}
```
使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。

#### 有缓冲区的通道

可以在使用make函数初始化通道的时候为其指定通道的容量，例如：

```go
func main() {
    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道
    ch <- 10
    fmt.Println("发送成功")
}
```

### close()

可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）

```go
package main

import "fmt"

func main() {
    c := make(chan int)
    go func() {
        for i := 0; i < 5; i++ {
            c <- i
        }
        close(c)
    }()
    for {
        if data, ok := <-c; ok {
            fmt.Println(data)
        } else {
            break
        }
    }
    fmt.Println("main结束")
}
```

### 通道循环取值

```go
ch2 := make(chan int)    
for i := range ch2 { // 通道关闭后会退出for range循环
    fmt.Println(i)
}
```

### 单向通道

[单向通道](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html#%E5%8D%95%E5%90%91%E9%80%9A%E9%81%93)



## 定时器

[并发编程/定时器](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%AE%9A%E6%97%B6%E5%99%A8.html)

- Timer：时间到了，执行只执行1次

- Ticker：时间到了，多次执行

## select

在某些场景下我们需要同时从多个通道接收数据。

select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：

```go
select {
case <-chan1:
// 如果chan1成功读到数据，则进行该case处理语句
case chan2 <- 1:
// 如果成功向chan2写入数据，则进行该case处理语句
default:
// 如果上面都没有成功，则进入default处理流程
}
```

- select可以同时监听一个或多个channel，直到其中一个channel ready
- 如果多个channel同时ready，则随机选择一个执行

- 可以用于判断管道是否存满

```go
select {
// 写数据
case ch <- "hello":
fmt.Println("write hello")
default:
fmt.Println("channel full")
}
```

## 并发安全和锁

有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。

### sync.Mutex互斥锁

它能够保证同时只有一个goroutine可以访问共享资源。

```go
var lock sync.Mutex
func add() {
    for i := 0; i < 5000; i++ {
        lock.Lock() // 加锁
        x = x + 1
        lock.Unlock() // 解锁
    }
    wg.Done()
}
```

### sync.RWMutex读写互斥锁

互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。

读写锁分为两种：读锁和写锁。

- 当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；
- 当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。

```go
var rwlock sync.RWMutex
func write() {
    rwlock.Lock() // 加写锁
    x = x + 1
    rwlock.Unlock()                   // 解写锁
    wg.Done()
}

func read() {
    rwlock.RLock()               // 加读锁
    rwlock.RUnlock()             // 解读锁
    wg.Done()
}
```

### sync.WaitGroup

Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：

| 方法名                          | 功能                |
| ------------------------------- | ------------------- |
| (wg * WaitGroup) Add(delta int) | 计数器+delta        |
| (wg *WaitGroup) Done()          | 计数器-1            |
| (wg *WaitGroup) Wait()          | 阻塞直到计数器变为0 |

sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。

### sync.Once

确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。

[sync.Once](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.html)

### sync.Map
Go语言中内置的map不是并发安全的[sync.Map](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.html)