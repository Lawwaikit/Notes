# 1.if语句

Go 的 if 语句与 for 循环类似，表达式外无需小括号 ( )，而大括号 { } 则是必须的
```go
func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}
```

if 语句可以在条件表达式前执行一个简短语句。该语句声明的变量作用域仅在 if 之内(else块中也可以使用)
```go
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}
```

# 2.for语句

基本的 for 循环由三部分组成，它们用分号隔开：

- 初始化语句：在第一次迭代前执行
- 条件表达式：在每次迭代前求值
- 后置语句：在每次迭代的结尾执行
```go

func main() {
	sum := 0
	for i := 0; i <= 100; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

初始化语句和后置语句是可选的
```go
func main() {
	sum := 1
	for  sum <= 100 {
		sum += sum
	}
	fmt.Println(sum)
}
```
如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑
```go
func main() {
	for {
	}
}
```
### for range语句
range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。
for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环
```go
for key, value := range oldMap {
    newMap[key] = value
}
```

# 3.switch语句
Go 只会运行选定的 case，而非之后所有的 case。 在效果上，Go 的做法相当于这些语言中为每个 case 后面自动添加了所需的 break 语句
switch 的 case 语句从上到下顺次执行，直到匹配成功时停止
```go
func main() {
	fmt.Print("Go 运行的系统环境：")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("macOS.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
}
```
### 无条件 switch
```go
func main() {
	t := time.Now()
	fmt.Println(t)
	switch {
	case t.Hour() < 12:
		fmt.Println("早上好！")
	case t.Hour() < 17:
		fmt.Println("下午好！")
	default:
		fmt.Println("晚上好！")
	}
}
````

# 4.defer 推迟
defer 语句会将函数推迟到外层函数返回之后执行。

推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。
```go
package main

import "fmt"

func aa(x string) string {
	fmt.Println("aa")
	return x
}

func main() {
	defer fmt.Println(aa("world"))

	fmt.Println("hello")
}

// console out
aa
hello
world
```

### defer 栈

推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。

更多关于 defer 语句的信息，请阅读[此博文](http://blog.go-zh.org/defer-panic-and-recover)。
```go
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
//console out
counting
done
9
8
7
6
5
4
3
2
1
0
```
