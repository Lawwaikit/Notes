# 基本类型

## 值类型
```go
bool
int(32 or 64), int8, int16, int32, int64
uint(32 or 64), uint8(byte), uint16, uint32, uint64
float32, float64
string
complex64, complex128
array    // 固定长度的数组
```
## 引用类型：(指针类型)
```go
slice   -- 序列数组(最常用)
map     -- 映射
chan    -- 管道
```

# 基本数据类型介绍
Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。

| 类型           | 长度(字节) | 默认值   | 说明                                                                 |
|----------------|------------|----------|----------------------------------------------------------------------|
| bool           | 1          | false    |                                                                      |
| byte           | 1          | 0        | uint8                                                                |
| rune           | 4          | 0        | Unicode Code Point, int32                                            |
| int, uint      | 4或8       | 0        | 32 或 64 位                                                          |
| int8, uint8    | 1          | 0        | -128 ~ 127, 0 ~ 255，byte是uint8 的别名                             |
| int16, uint16  | 2          | 0        | -32768 ~ 32767, 0 ~ 65535                                           |
| int32, uint32  | 4          | 0        | -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名                           |
| int64, uint64  | 8          | 0        |                                                                      |
| float32        | 4          | 0.0      |                                                                      |
| float64        | 8          | 0.0      |                                                                      |
| complex64      | 8          |          |                                                                      |
| complex128     | 16         |          |                                                                      |
| uintptr        | 4或8       |          | 以存储指针的 uint32 或 uint64 整数                                   |
| array          |            |          | 值类型                                                               |
| struct         |            |          | 值类型                                                               |
| string         |            | ""       | UTF-8 字符串                                                        |
| slice          |            | nil      | 引用类型                                                             |
| map            |            | nil      | 引用类型                                                             |
| channel        |            | nil      | 引用类型                                                             |
| interface      |            | nil      | 接口                                                                 |
| function       |            | nil      | 函数                                                                 |

## 整型
整型分为以下两个大类： 按长度分为：int8、int16、int32、int64对应的无符号整型：uint8、uint16、uint32、uint64

其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。
## 浮点型
Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。
## 复数
complex64和complex128

复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。
## 布尔值
Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。
注意：
- 布尔类型变量的默认值为false。
- Go 语言中不允许将整型强制转换为布尔型.
- 布尔型无法参与数值运算，也无法与其他类型进行转换。
## 字符串
Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(")中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：
```go
s1 := "hello"
s2 := "你好"
```

### 字符串的各种函数



[字符串](https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html#%E5%AD%97%E7%AC%A6%E4%B8%B2)



## byte和rune类型




## 类型转换

# 数组array


1. 数组：是同一种数据类型的固定长度的序列。
2. 数组定义：var a [len]int，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。
3. **长度是数组类型的一部分**，因此，var a[5] int和var a[10]int是不同的类型。

5. 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic
6. 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。
7.支持 "=="、"!=" 操作符，因为内存总是被初始化过的。
8.指针数组 [n]*T，数组指针 *[n]T。


### 数组定义和初始化

```go
var arr0 [5]int = [5]int{1, 2, 3}	// 未初始化元素值为 0
var arr1 = [5]int{1, 2, 3, 4, 5}	
var arr2 = [...]int{1, 2, 3, 4, 5, 6}// 通过初始化值确定数组长度
var str = [5]string{3: "hello world", 4: "tom"}	// 使用索引号初始化元素

d := [...]struct {
        name string
        age  uint8
    }{
        {"user1", 10}, // 可省略元素类型。
        {"user2", 20}, // 别忘了最后一行的逗号。
    }
```

### 多维数组

```go
// 全局
var arr0 [5][3]int
var arr1 [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}}
// 局
a := [2][3]int{{1, 2, 3}, {4, 5, 6}}
b := [...][2]int{{1, 1}, {2, 2}, {3, 3}} // 第2纬度不能用 ...
```

### len,cap内置函数

内置函数 len 和 cap 都返回数组长度 (元素数量)。

```go
func main() {
    a := [2]int{}
    println(len(a), cap(a)) 
}
//2 2
```





# 切片slice

```te
1. 切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。
2. 切片的长度可以改变，因此，切片是一个可变的数组。
3. 切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 
4. cap可以求出slice最大扩张容量，不能超出数组限制。0 <= len(slice) <= len(array)，其中array是slice引用的数组。
5. 切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。
6. 如果 slice == nil，那么 len、cap 结果都等于 0。
```

### 切片 定义和初始化

```go
func main() { //下面展示创建切片的各种方式
   //1. 声明切片
    var s1 []int  //此时s1 == nil
    
   // 2. :=
   s2 := []int{}  //此时s2 == nil
    
   // 3.通过 make() 创建切片 参数len
   var s3 []int = make([]int, 0)
   // 4.通过 make() 创建切片 参数len cap
   var s4 []int = make([]int, 0, 0)

   // 5.初始化赋值
   s5 := []int{1, 2, 3}

   // 6.从数组切片
   arr := [5]int{1, 2, 3, 4, 5}
   s6 := arr[1:4]
}
```



### append内置函数

append ：向 slice 尾部添加数据，返回新的 slice 对象。

```go
package main

import (
    "fmt"
)

func main() {
    var a = []int{1, 2, 3}
    var b = []int{4, 5, 6}

    c := append(a, b...)
    fmt.Printf("slice c : %v\n", c)
    
    d := append(c, 7)
    fmt.Printf("slice d : %v\n", d)
    
    e := append(d, 8, 9, 10)
    fmt.Printf("slice e : %v\n", e)
}
```



# 结构体

一个 结构体（`struct`）就是一组 字段（field）。

Go语言中可以使用type关键字来定义自定义类型

### 结构体 定义和初始化

```go
type person struct {
    name string//同样类型的字段也可以写在一行
    city string
    age  int8
}

func main() {
    1. 基本实例化
    var p1 person
    p1.name = "pprof.cn"
    p1.city = "北京"
    p1.age = 18
    fmt.Printf("p1=%v\n", p1)  //p1={pprof.cn 北京 18}
    
    2. new关键字对结构体进行实例化，得到的是结构体的地址
    var p2 = new(person)
    fmt.Printf("%T\n", p2)     //*main.person
    fmt.Printf("p2=%#v\n", p2) //p2=&main.person{name:"", city:"", age:0}
    // Go语言中支持对结构体指针直接使用.来访问结构体的成员
    // 这里p2是person的指针
    p2.name = "测试"
    p2.age = 18
    p2.city = "北京"
    
    3. 使用&对结构体进行取地址操作,相当于new了。
    p3 := &person{}
    p3.name = "博客" //p3.name = "博客"其实在底层是(*p3).name = "博客"，这是Go语言帮我们实现的语法糖。
    
    4. 使用键值对初始化
    p5 := person{
        name: "pprof.cn",
        city: "北京",
        age:  18,
	}
    //也可以对结构体指针进行键值对初始化
    p6 := &person{
        name: "pprof.cn",
        city: "北京",
        age:  18,
    }
    //当某些字段没有初始值的时候，该字段可以不写
    p7 := &person{
        city: "北京",
    }
    //使用值的列表初始化
    p8 := &person{
        "pprof.cn",
        "北京",
        18,
    }
```

### 常见使用

匿名结构体

```go
    var user struct{Name string; Age int}
    user.Name = "pprof.cn"
    user.Age = 18
```





# Map

map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。

### map 定义和初始化
Go语言中 map的定义语法如下

```go
//定义 
var m map[KeyType]ValueType
//初始化分配内存
m = make(map[KeyType]ValueType, [cap]) //cap表示map的容量,非必须参数

// 或声明的时候填充元素
userInfo := map[string]string{
    "username": "pprof.cn",
    "password": "123456",
}
```

### 常见使用
```go

//判断某个键是否存在  value, ok := map[key]
// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
v, ok := scoreMap["张三"]
if ok {
	fmt.Println(v)
} else {
	fmt.Println("查无此人")
}

//遍历 map  for k, v := range map {}
for k, v := range xxmap {
	fmt.Println(k, v)
}
//只想遍历key的时候，可以按下面的写法
for k := range xxmap {
	fmt.Println(k)
}

//使用delete()内建函数从map中删除一组键值对  
delete(map, key)


}
```